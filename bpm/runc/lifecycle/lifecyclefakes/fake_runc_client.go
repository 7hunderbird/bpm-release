// Code generated by counterfeiter. DO NOT EDIT.
package lifecyclefakes

import (
	"bpm/runc/client"
	"io"
	"sync"

	"bpm/runc/lifecycle"
	specs "github.com/opencontainers/runtime-spec/specs-go"
)

type FakeRuncClient struct {
	CreateBundleStub        func(bundlePath string, jobSpec specs.Spec, user specs.User) error
	createBundleMutex       sync.RWMutex
	createBundleArgsForCall []struct {
		bundlePath string
		jobSpec    specs.Spec
		user       specs.User
	}
	createBundleReturns struct {
		result1 error
	}
	createBundleReturnsOnCall map[int]struct {
		result1 error
	}
	RunContainerStub        func(pidFilePath, bundlePath, containerID string, detach bool, stdout, stderr io.Writer) (int, error)
	runContainerMutex       sync.RWMutex
	runContainerArgsForCall []struct {
		pidFilePath string
		bundlePath  string
		containerID string
		detach      bool
		stdout      io.Writer
		stderr      io.Writer
	}
	runContainerReturns struct {
		result1 int
		result2 error
	}
	runContainerReturnsOnCall map[int]struct {
		result1 int
		result2 error
	}
	ExecStub        func(containerID, command string, stdin io.Reader, stdout, stderr io.Writer) error
	execMutex       sync.RWMutex
	execArgsForCall []struct {
		containerID string
		command     string
		stdin       io.Reader
		stdout      io.Writer
		stderr      io.Writer
	}
	execReturns struct {
		result1 error
	}
	execReturnsOnCall map[int]struct {
		result1 error
	}
	ContainerStateStub        func(containerID string) (*specs.State, error)
	containerStateMutex       sync.RWMutex
	containerStateArgsForCall []struct {
		containerID string
	}
	containerStateReturns struct {
		result1 *specs.State
		result2 error
	}
	containerStateReturnsOnCall map[int]struct {
		result1 *specs.State
		result2 error
	}
	ListContainersStub        func() ([]client.ContainerState, error)
	listContainersMutex       sync.RWMutex
	listContainersArgsForCall []struct{}
	listContainersReturns     struct {
		result1 []client.ContainerState
		result2 error
	}
	listContainersReturnsOnCall map[int]struct {
		result1 []client.ContainerState
		result2 error
	}
	SignalContainerStub        func(containerID string, signal client.Signal) error
	signalContainerMutex       sync.RWMutex
	signalContainerArgsForCall []struct {
		containerID string
		signal      client.Signal
	}
	signalContainerReturns struct {
		result1 error
	}
	signalContainerReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteContainerStub        func(containerID string) error
	deleteContainerMutex       sync.RWMutex
	deleteContainerArgsForCall []struct {
		containerID string
	}
	deleteContainerReturns struct {
		result1 error
	}
	deleteContainerReturnsOnCall map[int]struct {
		result1 error
	}
	DestroyBundleStub        func(bundlePath string) error
	destroyBundleMutex       sync.RWMutex
	destroyBundleArgsForCall []struct {
		bundlePath string
	}
	destroyBundleReturns struct {
		result1 error
	}
	destroyBundleReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRuncClient) CreateBundle(bundlePath string, jobSpec specs.Spec, user specs.User) error {
	fake.createBundleMutex.Lock()
	ret, specificReturn := fake.createBundleReturnsOnCall[len(fake.createBundleArgsForCall)]
	fake.createBundleArgsForCall = append(fake.createBundleArgsForCall, struct {
		bundlePath string
		jobSpec    specs.Spec
		user       specs.User
	}{bundlePath, jobSpec, user})
	fake.recordInvocation("CreateBundle", []interface{}{bundlePath, jobSpec, user})
	fake.createBundleMutex.Unlock()
	if fake.CreateBundleStub != nil {
		return fake.CreateBundleStub(bundlePath, jobSpec, user)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.createBundleReturns.result1
}

func (fake *FakeRuncClient) CreateBundleCallCount() int {
	fake.createBundleMutex.RLock()
	defer fake.createBundleMutex.RUnlock()
	return len(fake.createBundleArgsForCall)
}

func (fake *FakeRuncClient) CreateBundleArgsForCall(i int) (string, specs.Spec, specs.User) {
	fake.createBundleMutex.RLock()
	defer fake.createBundleMutex.RUnlock()
	return fake.createBundleArgsForCall[i].bundlePath, fake.createBundleArgsForCall[i].jobSpec, fake.createBundleArgsForCall[i].user
}

func (fake *FakeRuncClient) CreateBundleReturns(result1 error) {
	fake.CreateBundleStub = nil
	fake.createBundleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncClient) CreateBundleReturnsOnCall(i int, result1 error) {
	fake.CreateBundleStub = nil
	if fake.createBundleReturnsOnCall == nil {
		fake.createBundleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createBundleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncClient) RunContainer(pidFilePath string, bundlePath string, containerID string, detach bool, stdout io.Writer, stderr io.Writer) (int, error) {
	fake.runContainerMutex.Lock()
	ret, specificReturn := fake.runContainerReturnsOnCall[len(fake.runContainerArgsForCall)]
	fake.runContainerArgsForCall = append(fake.runContainerArgsForCall, struct {
		pidFilePath string
		bundlePath  string
		containerID string
		detach      bool
		stdout      io.Writer
		stderr      io.Writer
	}{pidFilePath, bundlePath, containerID, detach, stdout, stderr})
	fake.recordInvocation("RunContainer", []interface{}{pidFilePath, bundlePath, containerID, detach, stdout, stderr})
	fake.runContainerMutex.Unlock()
	if fake.RunContainerStub != nil {
		return fake.RunContainerStub(pidFilePath, bundlePath, containerID, detach, stdout, stderr)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.runContainerReturns.result1, fake.runContainerReturns.result2
}

func (fake *FakeRuncClient) RunContainerCallCount() int {
	fake.runContainerMutex.RLock()
	defer fake.runContainerMutex.RUnlock()
	return len(fake.runContainerArgsForCall)
}

func (fake *FakeRuncClient) RunContainerArgsForCall(i int) (string, string, string, bool, io.Writer, io.Writer) {
	fake.runContainerMutex.RLock()
	defer fake.runContainerMutex.RUnlock()
	return fake.runContainerArgsForCall[i].pidFilePath, fake.runContainerArgsForCall[i].bundlePath, fake.runContainerArgsForCall[i].containerID, fake.runContainerArgsForCall[i].detach, fake.runContainerArgsForCall[i].stdout, fake.runContainerArgsForCall[i].stderr
}

func (fake *FakeRuncClient) RunContainerReturns(result1 int, result2 error) {
	fake.RunContainerStub = nil
	fake.runContainerReturns = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeRuncClient) RunContainerReturnsOnCall(i int, result1 int, result2 error) {
	fake.RunContainerStub = nil
	if fake.runContainerReturnsOnCall == nil {
		fake.runContainerReturnsOnCall = make(map[int]struct {
			result1 int
			result2 error
		})
	}
	fake.runContainerReturnsOnCall[i] = struct {
		result1 int
		result2 error
	}{result1, result2}
}

func (fake *FakeRuncClient) Exec(containerID string, command string, stdin io.Reader, stdout io.Writer, stderr io.Writer) error {
	fake.execMutex.Lock()
	ret, specificReturn := fake.execReturnsOnCall[len(fake.execArgsForCall)]
	fake.execArgsForCall = append(fake.execArgsForCall, struct {
		containerID string
		command     string
		stdin       io.Reader
		stdout      io.Writer
		stderr      io.Writer
	}{containerID, command, stdin, stdout, stderr})
	fake.recordInvocation("Exec", []interface{}{containerID, command, stdin, stdout, stderr})
	fake.execMutex.Unlock()
	if fake.ExecStub != nil {
		return fake.ExecStub(containerID, command, stdin, stdout, stderr)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.execReturns.result1
}

func (fake *FakeRuncClient) ExecCallCount() int {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	return len(fake.execArgsForCall)
}

func (fake *FakeRuncClient) ExecArgsForCall(i int) (string, string, io.Reader, io.Writer, io.Writer) {
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	return fake.execArgsForCall[i].containerID, fake.execArgsForCall[i].command, fake.execArgsForCall[i].stdin, fake.execArgsForCall[i].stdout, fake.execArgsForCall[i].stderr
}

func (fake *FakeRuncClient) ExecReturns(result1 error) {
	fake.ExecStub = nil
	fake.execReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncClient) ExecReturnsOnCall(i int, result1 error) {
	fake.ExecStub = nil
	if fake.execReturnsOnCall == nil {
		fake.execReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.execReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncClient) ContainerState(containerID string) (*specs.State, error) {
	fake.containerStateMutex.Lock()
	ret, specificReturn := fake.containerStateReturnsOnCall[len(fake.containerStateArgsForCall)]
	fake.containerStateArgsForCall = append(fake.containerStateArgsForCall, struct {
		containerID string
	}{containerID})
	fake.recordInvocation("ContainerState", []interface{}{containerID})
	fake.containerStateMutex.Unlock()
	if fake.ContainerStateStub != nil {
		return fake.ContainerStateStub(containerID)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.containerStateReturns.result1, fake.containerStateReturns.result2
}

func (fake *FakeRuncClient) ContainerStateCallCount() int {
	fake.containerStateMutex.RLock()
	defer fake.containerStateMutex.RUnlock()
	return len(fake.containerStateArgsForCall)
}

func (fake *FakeRuncClient) ContainerStateArgsForCall(i int) string {
	fake.containerStateMutex.RLock()
	defer fake.containerStateMutex.RUnlock()
	return fake.containerStateArgsForCall[i].containerID
}

func (fake *FakeRuncClient) ContainerStateReturns(result1 *specs.State, result2 error) {
	fake.ContainerStateStub = nil
	fake.containerStateReturns = struct {
		result1 *specs.State
		result2 error
	}{result1, result2}
}

func (fake *FakeRuncClient) ContainerStateReturnsOnCall(i int, result1 *specs.State, result2 error) {
	fake.ContainerStateStub = nil
	if fake.containerStateReturnsOnCall == nil {
		fake.containerStateReturnsOnCall = make(map[int]struct {
			result1 *specs.State
			result2 error
		})
	}
	fake.containerStateReturnsOnCall[i] = struct {
		result1 *specs.State
		result2 error
	}{result1, result2}
}

func (fake *FakeRuncClient) ListContainers() ([]client.ContainerState, error) {
	fake.listContainersMutex.Lock()
	ret, specificReturn := fake.listContainersReturnsOnCall[len(fake.listContainersArgsForCall)]
	fake.listContainersArgsForCall = append(fake.listContainersArgsForCall, struct{}{})
	fake.recordInvocation("ListContainers", []interface{}{})
	fake.listContainersMutex.Unlock()
	if fake.ListContainersStub != nil {
		return fake.ListContainersStub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.listContainersReturns.result1, fake.listContainersReturns.result2
}

func (fake *FakeRuncClient) ListContainersCallCount() int {
	fake.listContainersMutex.RLock()
	defer fake.listContainersMutex.RUnlock()
	return len(fake.listContainersArgsForCall)
}

func (fake *FakeRuncClient) ListContainersReturns(result1 []client.ContainerState, result2 error) {
	fake.ListContainersStub = nil
	fake.listContainersReturns = struct {
		result1 []client.ContainerState
		result2 error
	}{result1, result2}
}

func (fake *FakeRuncClient) ListContainersReturnsOnCall(i int, result1 []client.ContainerState, result2 error) {
	fake.ListContainersStub = nil
	if fake.listContainersReturnsOnCall == nil {
		fake.listContainersReturnsOnCall = make(map[int]struct {
			result1 []client.ContainerState
			result2 error
		})
	}
	fake.listContainersReturnsOnCall[i] = struct {
		result1 []client.ContainerState
		result2 error
	}{result1, result2}
}

func (fake *FakeRuncClient) SignalContainer(containerID string, signal client.Signal) error {
	fake.signalContainerMutex.Lock()
	ret, specificReturn := fake.signalContainerReturnsOnCall[len(fake.signalContainerArgsForCall)]
	fake.signalContainerArgsForCall = append(fake.signalContainerArgsForCall, struct {
		containerID string
		signal      client.Signal
	}{containerID, signal})
	fake.recordInvocation("SignalContainer", []interface{}{containerID, signal})
	fake.signalContainerMutex.Unlock()
	if fake.SignalContainerStub != nil {
		return fake.SignalContainerStub(containerID, signal)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.signalContainerReturns.result1
}

func (fake *FakeRuncClient) SignalContainerCallCount() int {
	fake.signalContainerMutex.RLock()
	defer fake.signalContainerMutex.RUnlock()
	return len(fake.signalContainerArgsForCall)
}

func (fake *FakeRuncClient) SignalContainerArgsForCall(i int) (string, client.Signal) {
	fake.signalContainerMutex.RLock()
	defer fake.signalContainerMutex.RUnlock()
	return fake.signalContainerArgsForCall[i].containerID, fake.signalContainerArgsForCall[i].signal
}

func (fake *FakeRuncClient) SignalContainerReturns(result1 error) {
	fake.SignalContainerStub = nil
	fake.signalContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncClient) SignalContainerReturnsOnCall(i int, result1 error) {
	fake.SignalContainerStub = nil
	if fake.signalContainerReturnsOnCall == nil {
		fake.signalContainerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.signalContainerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncClient) DeleteContainer(containerID string) error {
	fake.deleteContainerMutex.Lock()
	ret, specificReturn := fake.deleteContainerReturnsOnCall[len(fake.deleteContainerArgsForCall)]
	fake.deleteContainerArgsForCall = append(fake.deleteContainerArgsForCall, struct {
		containerID string
	}{containerID})
	fake.recordInvocation("DeleteContainer", []interface{}{containerID})
	fake.deleteContainerMutex.Unlock()
	if fake.DeleteContainerStub != nil {
		return fake.DeleteContainerStub(containerID)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.deleteContainerReturns.result1
}

func (fake *FakeRuncClient) DeleteContainerCallCount() int {
	fake.deleteContainerMutex.RLock()
	defer fake.deleteContainerMutex.RUnlock()
	return len(fake.deleteContainerArgsForCall)
}

func (fake *FakeRuncClient) DeleteContainerArgsForCall(i int) string {
	fake.deleteContainerMutex.RLock()
	defer fake.deleteContainerMutex.RUnlock()
	return fake.deleteContainerArgsForCall[i].containerID
}

func (fake *FakeRuncClient) DeleteContainerReturns(result1 error) {
	fake.DeleteContainerStub = nil
	fake.deleteContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncClient) DeleteContainerReturnsOnCall(i int, result1 error) {
	fake.DeleteContainerStub = nil
	if fake.deleteContainerReturnsOnCall == nil {
		fake.deleteContainerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteContainerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncClient) DestroyBundle(bundlePath string) error {
	fake.destroyBundleMutex.Lock()
	ret, specificReturn := fake.destroyBundleReturnsOnCall[len(fake.destroyBundleArgsForCall)]
	fake.destroyBundleArgsForCall = append(fake.destroyBundleArgsForCall, struct {
		bundlePath string
	}{bundlePath})
	fake.recordInvocation("DestroyBundle", []interface{}{bundlePath})
	fake.destroyBundleMutex.Unlock()
	if fake.DestroyBundleStub != nil {
		return fake.DestroyBundleStub(bundlePath)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.destroyBundleReturns.result1
}

func (fake *FakeRuncClient) DestroyBundleCallCount() int {
	fake.destroyBundleMutex.RLock()
	defer fake.destroyBundleMutex.RUnlock()
	return len(fake.destroyBundleArgsForCall)
}

func (fake *FakeRuncClient) DestroyBundleArgsForCall(i int) string {
	fake.destroyBundleMutex.RLock()
	defer fake.destroyBundleMutex.RUnlock()
	return fake.destroyBundleArgsForCall[i].bundlePath
}

func (fake *FakeRuncClient) DestroyBundleReturns(result1 error) {
	fake.DestroyBundleStub = nil
	fake.destroyBundleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncClient) DestroyBundleReturnsOnCall(i int, result1 error) {
	fake.DestroyBundleStub = nil
	if fake.destroyBundleReturnsOnCall == nil {
		fake.destroyBundleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyBundleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createBundleMutex.RLock()
	defer fake.createBundleMutex.RUnlock()
	fake.runContainerMutex.RLock()
	defer fake.runContainerMutex.RUnlock()
	fake.execMutex.RLock()
	defer fake.execMutex.RUnlock()
	fake.containerStateMutex.RLock()
	defer fake.containerStateMutex.RUnlock()
	fake.listContainersMutex.RLock()
	defer fake.listContainersMutex.RUnlock()
	fake.signalContainerMutex.RLock()
	defer fake.signalContainerMutex.RUnlock()
	fake.deleteContainerMutex.RLock()
	defer fake.deleteContainerMutex.RUnlock()
	fake.destroyBundleMutex.RLock()
	defer fake.destroyBundleMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeRuncClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ lifecycle.RuncClient = new(FakeRuncClient)
