// This file was generated by counterfeiter
package runcadapterfakes

import (
	"crucible/config"
	"crucible/runcadapter"
	"io"
	"os"
	"sync"

	specs "github.com/opencontainers/runtime-spec/specs-go"
)

type FakeRuncAdapter struct {
	BuildSpecStub        func(jobName string, jobConfig *config.CrucibleConfig) (specs.Spec, error)
	buildSpecMutex       sync.RWMutex
	buildSpecArgsForCall []struct {
		jobName   string
		jobConfig *config.CrucibleConfig
	}
	buildSpecReturns struct {
		result1 specs.Spec
		result2 error
	}
	buildSpecReturnsOnCall map[int]struct {
		result1 specs.Spec
		result2 error
	}
	CreateBundleStub        func(bundlesRoot, jobName string, jobSpec specs.Spec) (string, error)
	createBundleMutex       sync.RWMutex
	createBundleArgsForCall []struct {
		bundlesRoot string
		jobName     string
		jobSpec     specs.Spec
	}
	createBundleReturns struct {
		result1 string
		result2 error
	}
	createBundleReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	CreateSystemFilesStub        func(systemRoot, jobName string) (string, *os.File, *os.File, error)
	createSystemFilesMutex       sync.RWMutex
	createSystemFilesArgsForCall []struct {
		systemRoot string
		jobName    string
	}
	createSystemFilesReturns struct {
		result1 string
		result2 *os.File
		result3 *os.File
		result4 error
	}
	createSystemFilesReturnsOnCall map[int]struct {
		result1 string
		result2 *os.File
		result3 *os.File
		result4 error
	}
	RunContainerStub        func(pidDir, bundlePath, jobName string, stdout, stderr io.Writer) error
	runContainerMutex       sync.RWMutex
	runContainerArgsForCall []struct {
		pidDir     string
		bundlePath string
		jobName    string
		stdout     io.Writer
		stderr     io.Writer
	}
	runContainerReturns struct {
		result1 error
	}
	runContainerReturnsOnCall map[int]struct {
		result1 error
	}
	StopContainerStub        func(jobName string) error
	stopContainerMutex       sync.RWMutex
	stopContainerArgsForCall []struct {
		jobName string
	}
	stopContainerReturns struct {
		result1 error
	}
	stopContainerReturnsOnCall map[int]struct {
		result1 error
	}
	DestroyBundleStub        func(bundlesRoot, jobName string) error
	destroyBundleMutex       sync.RWMutex
	destroyBundleArgsForCall []struct {
		bundlesRoot string
		jobName     string
	}
	destroyBundleReturns struct {
		result1 error
	}
	destroyBundleReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeRuncAdapter) BuildSpec(jobName string, jobConfig *config.CrucibleConfig) (specs.Spec, error) {
	fake.buildSpecMutex.Lock()
	ret, specificReturn := fake.buildSpecReturnsOnCall[len(fake.buildSpecArgsForCall)]
	fake.buildSpecArgsForCall = append(fake.buildSpecArgsForCall, struct {
		jobName   string
		jobConfig *config.CrucibleConfig
	}{jobName, jobConfig})
	fake.recordInvocation("BuildSpec", []interface{}{jobName, jobConfig})
	fake.buildSpecMutex.Unlock()
	if fake.BuildSpecStub != nil {
		return fake.BuildSpecStub(jobName, jobConfig)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.buildSpecReturns.result1, fake.buildSpecReturns.result2
}

func (fake *FakeRuncAdapter) BuildSpecCallCount() int {
	fake.buildSpecMutex.RLock()
	defer fake.buildSpecMutex.RUnlock()
	return len(fake.buildSpecArgsForCall)
}

func (fake *FakeRuncAdapter) BuildSpecArgsForCall(i int) (string, *config.CrucibleConfig) {
	fake.buildSpecMutex.RLock()
	defer fake.buildSpecMutex.RUnlock()
	return fake.buildSpecArgsForCall[i].jobName, fake.buildSpecArgsForCall[i].jobConfig
}

func (fake *FakeRuncAdapter) BuildSpecReturns(result1 specs.Spec, result2 error) {
	fake.BuildSpecStub = nil
	fake.buildSpecReturns = struct {
		result1 specs.Spec
		result2 error
	}{result1, result2}
}

func (fake *FakeRuncAdapter) BuildSpecReturnsOnCall(i int, result1 specs.Spec, result2 error) {
	fake.BuildSpecStub = nil
	if fake.buildSpecReturnsOnCall == nil {
		fake.buildSpecReturnsOnCall = make(map[int]struct {
			result1 specs.Spec
			result2 error
		})
	}
	fake.buildSpecReturnsOnCall[i] = struct {
		result1 specs.Spec
		result2 error
	}{result1, result2}
}

func (fake *FakeRuncAdapter) CreateBundle(bundlesRoot string, jobName string, jobSpec specs.Spec) (string, error) {
	fake.createBundleMutex.Lock()
	ret, specificReturn := fake.createBundleReturnsOnCall[len(fake.createBundleArgsForCall)]
	fake.createBundleArgsForCall = append(fake.createBundleArgsForCall, struct {
		bundlesRoot string
		jobName     string
		jobSpec     specs.Spec
	}{bundlesRoot, jobName, jobSpec})
	fake.recordInvocation("CreateBundle", []interface{}{bundlesRoot, jobName, jobSpec})
	fake.createBundleMutex.Unlock()
	if fake.CreateBundleStub != nil {
		return fake.CreateBundleStub(bundlesRoot, jobName, jobSpec)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fake.createBundleReturns.result1, fake.createBundleReturns.result2
}

func (fake *FakeRuncAdapter) CreateBundleCallCount() int {
	fake.createBundleMutex.RLock()
	defer fake.createBundleMutex.RUnlock()
	return len(fake.createBundleArgsForCall)
}

func (fake *FakeRuncAdapter) CreateBundleArgsForCall(i int) (string, string, specs.Spec) {
	fake.createBundleMutex.RLock()
	defer fake.createBundleMutex.RUnlock()
	return fake.createBundleArgsForCall[i].bundlesRoot, fake.createBundleArgsForCall[i].jobName, fake.createBundleArgsForCall[i].jobSpec
}

func (fake *FakeRuncAdapter) CreateBundleReturns(result1 string, result2 error) {
	fake.CreateBundleStub = nil
	fake.createBundleReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRuncAdapter) CreateBundleReturnsOnCall(i int, result1 string, result2 error) {
	fake.CreateBundleStub = nil
	if fake.createBundleReturnsOnCall == nil {
		fake.createBundleReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.createBundleReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeRuncAdapter) CreateSystemFiles(systemRoot string, jobName string) (string, *os.File, *os.File, error) {
	fake.createSystemFilesMutex.Lock()
	ret, specificReturn := fake.createSystemFilesReturnsOnCall[len(fake.createSystemFilesArgsForCall)]
	fake.createSystemFilesArgsForCall = append(fake.createSystemFilesArgsForCall, struct {
		systemRoot string
		jobName    string
	}{systemRoot, jobName})
	fake.recordInvocation("CreateSystemFiles", []interface{}{systemRoot, jobName})
	fake.createSystemFilesMutex.Unlock()
	if fake.CreateSystemFilesStub != nil {
		return fake.CreateSystemFilesStub(systemRoot, jobName)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3, ret.result4
	}
	return fake.createSystemFilesReturns.result1, fake.createSystemFilesReturns.result2, fake.createSystemFilesReturns.result3, fake.createSystemFilesReturns.result4
}

func (fake *FakeRuncAdapter) CreateSystemFilesCallCount() int {
	fake.createSystemFilesMutex.RLock()
	defer fake.createSystemFilesMutex.RUnlock()
	return len(fake.createSystemFilesArgsForCall)
}

func (fake *FakeRuncAdapter) CreateSystemFilesArgsForCall(i int) (string, string) {
	fake.createSystemFilesMutex.RLock()
	defer fake.createSystemFilesMutex.RUnlock()
	return fake.createSystemFilesArgsForCall[i].systemRoot, fake.createSystemFilesArgsForCall[i].jobName
}

func (fake *FakeRuncAdapter) CreateSystemFilesReturns(result1 string, result2 *os.File, result3 *os.File, result4 error) {
	fake.CreateSystemFilesStub = nil
	fake.createSystemFilesReturns = struct {
		result1 string
		result2 *os.File
		result3 *os.File
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeRuncAdapter) CreateSystemFilesReturnsOnCall(i int, result1 string, result2 *os.File, result3 *os.File, result4 error) {
	fake.CreateSystemFilesStub = nil
	if fake.createSystemFilesReturnsOnCall == nil {
		fake.createSystemFilesReturnsOnCall = make(map[int]struct {
			result1 string
			result2 *os.File
			result3 *os.File
			result4 error
		})
	}
	fake.createSystemFilesReturnsOnCall[i] = struct {
		result1 string
		result2 *os.File
		result3 *os.File
		result4 error
	}{result1, result2, result3, result4}
}

func (fake *FakeRuncAdapter) RunContainer(pidDir string, bundlePath string, jobName string, stdout io.Writer, stderr io.Writer) error {
	fake.runContainerMutex.Lock()
	ret, specificReturn := fake.runContainerReturnsOnCall[len(fake.runContainerArgsForCall)]
	fake.runContainerArgsForCall = append(fake.runContainerArgsForCall, struct {
		pidDir     string
		bundlePath string
		jobName    string
		stdout     io.Writer
		stderr     io.Writer
	}{pidDir, bundlePath, jobName, stdout, stderr})
	fake.recordInvocation("RunContainer", []interface{}{pidDir, bundlePath, jobName, stdout, stderr})
	fake.runContainerMutex.Unlock()
	if fake.RunContainerStub != nil {
		return fake.RunContainerStub(pidDir, bundlePath, jobName, stdout, stderr)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.runContainerReturns.result1
}

func (fake *FakeRuncAdapter) RunContainerCallCount() int {
	fake.runContainerMutex.RLock()
	defer fake.runContainerMutex.RUnlock()
	return len(fake.runContainerArgsForCall)
}

func (fake *FakeRuncAdapter) RunContainerArgsForCall(i int) (string, string, string, io.Writer, io.Writer) {
	fake.runContainerMutex.RLock()
	defer fake.runContainerMutex.RUnlock()
	return fake.runContainerArgsForCall[i].pidDir, fake.runContainerArgsForCall[i].bundlePath, fake.runContainerArgsForCall[i].jobName, fake.runContainerArgsForCall[i].stdout, fake.runContainerArgsForCall[i].stderr
}

func (fake *FakeRuncAdapter) RunContainerReturns(result1 error) {
	fake.RunContainerStub = nil
	fake.runContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncAdapter) RunContainerReturnsOnCall(i int, result1 error) {
	fake.RunContainerStub = nil
	if fake.runContainerReturnsOnCall == nil {
		fake.runContainerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.runContainerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncAdapter) StopContainer(jobName string) error {
	fake.stopContainerMutex.Lock()
	ret, specificReturn := fake.stopContainerReturnsOnCall[len(fake.stopContainerArgsForCall)]
	fake.stopContainerArgsForCall = append(fake.stopContainerArgsForCall, struct {
		jobName string
	}{jobName})
	fake.recordInvocation("StopContainer", []interface{}{jobName})
	fake.stopContainerMutex.Unlock()
	if fake.StopContainerStub != nil {
		return fake.StopContainerStub(jobName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.stopContainerReturns.result1
}

func (fake *FakeRuncAdapter) StopContainerCallCount() int {
	fake.stopContainerMutex.RLock()
	defer fake.stopContainerMutex.RUnlock()
	return len(fake.stopContainerArgsForCall)
}

func (fake *FakeRuncAdapter) StopContainerArgsForCall(i int) string {
	fake.stopContainerMutex.RLock()
	defer fake.stopContainerMutex.RUnlock()
	return fake.stopContainerArgsForCall[i].jobName
}

func (fake *FakeRuncAdapter) StopContainerReturns(result1 error) {
	fake.StopContainerStub = nil
	fake.stopContainerReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncAdapter) StopContainerReturnsOnCall(i int, result1 error) {
	fake.StopContainerStub = nil
	if fake.stopContainerReturnsOnCall == nil {
		fake.stopContainerReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.stopContainerReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncAdapter) DestroyBundle(bundlesRoot string, jobName string) error {
	fake.destroyBundleMutex.Lock()
	ret, specificReturn := fake.destroyBundleReturnsOnCall[len(fake.destroyBundleArgsForCall)]
	fake.destroyBundleArgsForCall = append(fake.destroyBundleArgsForCall, struct {
		bundlesRoot string
		jobName     string
	}{bundlesRoot, jobName})
	fake.recordInvocation("DestroyBundle", []interface{}{bundlesRoot, jobName})
	fake.destroyBundleMutex.Unlock()
	if fake.DestroyBundleStub != nil {
		return fake.DestroyBundleStub(bundlesRoot, jobName)
	}
	if specificReturn {
		return ret.result1
	}
	return fake.destroyBundleReturns.result1
}

func (fake *FakeRuncAdapter) DestroyBundleCallCount() int {
	fake.destroyBundleMutex.RLock()
	defer fake.destroyBundleMutex.RUnlock()
	return len(fake.destroyBundleArgsForCall)
}

func (fake *FakeRuncAdapter) DestroyBundleArgsForCall(i int) (string, string) {
	fake.destroyBundleMutex.RLock()
	defer fake.destroyBundleMutex.RUnlock()
	return fake.destroyBundleArgsForCall[i].bundlesRoot, fake.destroyBundleArgsForCall[i].jobName
}

func (fake *FakeRuncAdapter) DestroyBundleReturns(result1 error) {
	fake.DestroyBundleStub = nil
	fake.destroyBundleReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncAdapter) DestroyBundleReturnsOnCall(i int, result1 error) {
	fake.DestroyBundleStub = nil
	if fake.destroyBundleReturnsOnCall == nil {
		fake.destroyBundleReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.destroyBundleReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeRuncAdapter) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.buildSpecMutex.RLock()
	defer fake.buildSpecMutex.RUnlock()
	fake.createBundleMutex.RLock()
	defer fake.createBundleMutex.RUnlock()
	fake.createSystemFilesMutex.RLock()
	defer fake.createSystemFilesMutex.RUnlock()
	fake.runContainerMutex.RLock()
	defer fake.runContainerMutex.RUnlock()
	fake.stopContainerMutex.RLock()
	defer fake.stopContainerMutex.RUnlock()
	fake.destroyBundleMutex.RLock()
	defer fake.destroyBundleMutex.RUnlock()
	return fake.invocations
}

func (fake *FakeRuncAdapter) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ runcadapter.RuncAdapter = new(FakeRuncAdapter)
